<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chef-patterns | Quick Notes]]></title>
  <link href="http://asquareb.github.io/blog/categories/chef-patterns/atom.xml" rel="self"/>
  <link href="http://asquareb.github.io/"/>
  <updated>2022-01-23T21:54:33-08:00</updated>
  <id>http://asquareb.github.io/</id>
  <author>
    <name><![CDATA[asquareb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Integrating Chef and Apache ZooKeeper for Coordination in a Cluster]]></title>
    <link href="http://asquareb.github.io/blog/2015/04/03/integrating-chef-and-apache-zookeeper-for-coordination-in-a-cluster/"/>
    <updated>2015-04-03T23:36:21-04:00</updated>
    <id>http://asquareb.github.io/blog/2015/04/03/integrating-chef-and-apache-zookeeper-for-coordination-in-a-cluster</id>
    <content type="html"><![CDATA[<p>In a cluster environment services on nodes may have to be coordinated for various reasons. For e.g., when a configuration change is made to a distributed computing component like <code>HDFS</code>, the <code>HDFS</code> service on all nodes shouldn&rsquo;t stop at the same time to restart so that the configuration takes in effect. Stopping of the service on all the nodes will end up in unavailability which is not desired to put it lightly.</p>

<p>There are many options to perform orchestration/coordination with varied maturity when you manage a cluster using <code>Chef</code>. Here we look at how <code>Chef</code> and <code>ZooKeeper</code> can work together to perform coordination of services on cluster nodes. We will use the need to control and coordinate service restart so that the service in all nodes are not stopped at the same time as the example to explain the solution.</p>

<!--more-->


<p>Lets take the simple case of service restart where only one instance of the service can be restarted at any time. One of the ways to accomplish this is by forcing nodes to acquire a lock to perform service restarts. The following is the solution summary</p>

<ul>
<li>A lock need to be acquired by a node before it can take a restart action on the service instance running on the node.</li>
<li>When a node tries to acquire a lock and if it fails since some other node is holding the lock or other reasons, the node waits and retries for a certain time.</li>
<li>If the lock is acquired within the certain prescribed time, the node restarts the service.</li>
<li>Once the restart is complete the node releases the lock so that other nodes can take a lock on it.</li>
<li>If the lock is not acquired within the certain time, the node remembers that the restart was not successful and hence will try to restart the service next time chef client runs on the node.</li>
</ul>


<p>If there are any misconfigurations which triggered the restart, the service will not be successfully restarted due to the misconfiguration on the node which acquired the lock first. Since the restart process failed, lock will not be released resulting in other nodes not being able to able to acquire it. This prevents misconfiguration being propagated to other nodes preventing unavailability. Also until the misconfiguration is corrected the service will not be restarted in all the nodes.</p>

<p>Now the key is to be able to implement lock primitive in a distributed environment and this is where <a href="https://zookeeper.apache.org/">Apache ZooKeeper</a> comes into play. <code>ZooKeeper</code> is a high-performance coordination service which among many things provides synchronization for distributed applications. <code>ZooKeeper</code> is used by many Apache projects like <code>HBase</code> which is a distributed scalable data store. <code>ZooKeeper</code> is also a distributed system which means failover is handled automatically preventing unavailability.</p>

<p>For the use case of allowing only one node to restart a service, we can use ZooKeeper “znode” as the lock. For a service “X”, if a node is able to create a znode “X” in ZooKeeper then the service can be restarted by the node. If a node is not able to create znode “X” since the znode is already created by another node in the cluster or other reasons, then the node need to wait until the znode is removed.</p>

<p>The following is a Chef <a href="https://github.com/bijugs/chef-bach/blob/master_rolling_restart/cookbooks/bcpc-hadoop/definitions/hadoop_service.rb"><code>definition</code></a> which implements the restart coordination logic. It is implemented as a <code>definition</code> so that it can be used to coordinate the restart of multiple services in a cluster. The inline comments in the code explains the logic and any reference to hadoop can be discarded since this can be used for any service. Currently this is implemented and used for a hadoop cluster.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>Definition takes three parameters&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>service_name: Name of the service&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>dependencies: Resources typically template resources for which the service need to be restarted&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>process_identifier: String which identifies the process of the service&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>#
</span><span class='line'>define :hadoop_service, :service_name => nil, :dependencies => nil, :process_identifier => nil do&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  params[:service_name] ||= params[:name]
</span><span class='line'>  #
</span><span class='line'>  # Service resource defined using the parameters passed
</span><span class='line'>  #
</span><span class='line'>  service &ldquo;#{params[:service_name]}&rdquo; do
</span><span class='line'>    supports :status => true, :restart => true, :reload => false
</span><span class='line'>    action [:enable, :start]
</span><span class='line'>  end
</span><span class='line'>  #
</span><span class='line'>  # Checking to see whether user requested to not to use restart coordination
</span><span class='line'>  #
</span><span class='line'>  if node[&ldquo;bcpc&rdquo;][&ldquo;hadoop&rdquo;][&ldquo;skip_restart_coordination&rdquo;]
</span><span class='line'>    Chef::Log.info &ldquo;Coordination of #{params[:service_name]} restart will be skipped as per user request.&rdquo;
</span><span class='line'>    begin
</span><span class='line'>      res = resources(service: &ldquo;#{params[:service_name]}&rdquo;)
</span><span class='line'>      if params[:dependencies]
</span><span class='line'>        params[:dependencies].each do |dep|
</span><span class='line'>          res.subscribes(:restart, &ldquo;#{dep}&rdquo;, :delayed)
</span><span class='line'>        end
</span><span class='line'>      end
</span><span class='line'>    rescue Chef::Exceptions::ResourceNotFound
</span><span class='line'>      Chef::Log.info(&ldquo;Resource service #{params[:service_name]} not found&rdquo;)
</span><span class='line'>    end
</span><span class='line'>  else
</span><span class='line'>    if !params[:process_identifier]
</span><span class='line'>      Chef::Application.fatal!(&ldquo;hadoop_service for #{params[:service_name]} need to specify a valid value for the parameter :process_identifier&rdquo;)
</span><span class='line'>    end
</span><span class='line'>    #
</span><span class='line'>    # When there is a need to restart a hadoop service, a lock need to be taken so that the restart is sequenced preventing all nodes being down at the sametime
</span><span class='line'>    # If there is a failure in acquiring a lock with in a certian period, the restart is scheduled for the next run on chef-client on the node.
</span><span class='line'>    # To determine whether the prev restart failed is the node attribute node[:bcpc][:hadoop][:service_name][:restart_failed] is set to true
</span><span class='line'>    # This ruby block is to check whether this node attribute is set to true and if it is set then gets the hadoop service restart process in motion.
</span><span class='line'>    #
</span><span class='line'>    ruby_block &ldquo;handle_prev&lt;em>#{params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;/em>&rsquo;)}&lt;em>restart_failure&rdquo; do
</span><span class='line'>      block do
</span><span class='line'>        Chef::Log.info &ldquo;Need to restart #{params[:service_name]} since it failed during the previous run. Another node&rsquo;s restart process failure is a possible reason&rdquo;
</span><span class='line'>      end
</span><span class='line'>      action :create
</span><span class='line'>      only_if { node[:bcpc][:hadoop][params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;/em>&rsquo;).to_sym][:restart_failed] and
</span><span class='line'>              !process_restarted_after_failure?(node[:bcpc][:hadoop][params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;em>&rsquo;).to_sym][:restart_failed_time],&ldquo;#{params[:process_identifier]}&rdquo;)}
</span><span class='line'>    end
</span><span class='line'>    #
</span><span class='line'>    # Since string with all the zookeeper nodes is used multiple times this variable is populated once and reused reducing calls to Chef server
</span><span class='line'>    #
</span><span class='line'>    zk_hosts = (get_node_attributes(MGMT_IP_ATTR_SRCH_KEYS,&ldquo;zookeeper_server&rdquo;,&ldquo;bcpc-hadoop&rdquo;).map{|zkhost| &ldquo;#{zkhost[&lsquo;mgmt_ip&rsquo;]}:#{node[:bcpc][:hadoop][:zookeeper][:port]}&rdquo;}).join(&ldquo;,&rdquo;)
</span><span class='line'>    #
</span><span class='line'>    # znode is used as the locking mechnism to control restart of services. The following code is to build the path
</span><span class='line'>    # to create the znode before initiating the restart of hadoop service
</span><span class='line'>    #
</span><span class='line'>    lock_znode_path = format_restart_lock_path(node[:bcpc][:hadoop][:restart_lock][:root],&ldquo;#{params[:service_name]}&rdquo;)
</span><span class='line'>    #
</span><span class='line'>    # All hadoop service restart situations like changes in config files or restart due to previous failures invokes this ruby_block
</span><span class='line'>    # This ruby block tries to acquire a lock and if not able to acquire the lock, sets the restart_failed node attribute to true
</span><span class='line'>    #
</span><span class='line'>    ruby_block &ldquo;acquire_lock_to_restart&lt;/em>#{params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;em>&rsquo;)}&rdquo; do
</span><span class='line'>      require &lsquo;time&rsquo;
</span><span class='line'>      block do
</span><span class='line'>        tries = 0
</span><span class='line'>        Chef::Log.info(&ldquo;#{node[:hostname]}: Acquring lock at #{lock_znode_path}&rdquo;)
</span><span class='line'>        while true
</span><span class='line'>          lock = acquire_restart_lock(lock_znode_path, zk_hosts, node[:fqdn])
</span><span class='line'>          if lock
</span><span class='line'>            break
</span><span class='line'>          else
</span><span class='line'>            tries += 1
</span><span class='line'>            if tries >= node[:bcpc][:hadoop][:restart_lock_acquire][:max_tries]
</span><span class='line'>              failure_time = Time.now().to_s
</span><span class='line'>              Chef::Log.info(&ldquo;Couldn&rsquo;t acquire lock to restart &rdquo;)
</span><span class='line'>              node.set[:bcpc][:hadoop][params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;/em>&rsquo;).to_sym][:restart_failed] = true
</span><span class='line'>              node.set[:bcpc][:hadoop][params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;em>&rsquo;).to_sym][:restart_failed_time] = failure_time
</span><span class='line'>              node.save
</span><span class='line'>              break
</span><span class='line'>            end
</span><span class='line'>            sleep(node[:bcpc][:hadoop][:restart_lock_acquire][:sleep_time])
</span><span class='line'>          end
</span><span class='line'>        end
</span><span class='line'>      end
</span><span class='line'>      action :nothing
</span><span class='line'>      if params[:dependencies]
</span><span class='line'>        params[:dependencies].each do |dep|
</span><span class='line'>          subscribes :create, &ldquo;#{dep}&rdquo;, :immediate
</span><span class='line'>        end
</span><span class='line'>      end
</span><span class='line'>      subscribes :create, &ldquo;ruby_block[handle_prev&lt;/em>#{params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;em>&rsquo;)}&lt;/em>restart_failure]&rdquo;, :immediate
</span><span class='line'>    end
</span><span class='line'>    #
</span><span class='line'>    # If lock is acquired by the node, ruby_block executes which is to notify service to restart
</span><span class='line'>    #
</span><span class='line'>    ruby_block &ldquo;coordinate&lt;em>#{params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;/em>&rsquo;)}_restart&rdquo; do
</span><span class='line'>      block do
</span><span class='line'>        Chef::Log.info(&ldquo;Data node will be restarted in node #{node[:fqdn]}&rdquo;)
</span><span class='line'>      end
</span><span class='line'>      action :create
</span><span class='line'>      only_if { my_restart_lock?(lock_znode_path, zk_hosts, node[:fqdn]) }
</span><span class='line'>    end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>begin
</span><span class='line'>  res = resources(service: "#{params[:service_name]}")
</span><span class='line'>  res.subscribes(:restart, "ruby_block[coordinate_#{params[:service_name].gsub('-','_')}_restart]", :immediate)
</span><span class='line'>rescue Chef::Exceptions::ResourceNotFound
</span><span class='line'>  Chef::Log.info("Resource service #{params[:service_name]} not found")
</span><span class='line'>end
</span><span class='line'>#
</span><span class='line'># Once the service restart is complete, the following block releases the lock 
</span><span class='line'>#
</span><span class='line'>ruby_block "release_#{params[:service_name].gsub('-','_')}_restart_lock" do
</span><span class='line'>  block do
</span><span class='line'>    Chef::Log.info("#{node[:hostname]}: Releasing lock at #{lock_znode_path}")
</span><span class='line'>    lock_rel = rel_restart_lock(lock_znode_path, zk_hosts, node[:fqdn])
</span><span class='line'>    if lock_rel
</span><span class='line'>      node.set[:bcpc][:hadoop][params[:service_name].gsub('-','_').to_sym][:restart_failed] = false
</span><span class='line'>      node.save
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>  action :create
</span><span class='line'>  only_if { my_restart_lock?(lock_znode_path, zk_hosts, node[:fqdn]) }
</span><span class='line'>end
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>The following code snippet is how it is used in recipes instead of the default Chef <code>service</code> resource.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;
</span><span class='line'>dep = [&ldquo;template[/etc/hadoop/conf/hdfs-site.xml]&rdquo;,
</span><span class='line'>       &ldquo;template[/etc/hadoop/conf/hadoop-env.sh]&rdquo;]&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>hadoop_service &ldquo;hadoop-hdfs-datanode&rdquo; do
</span><span class='line'>  dependencies dep
</span><span class='line'>  process_identifier &ldquo;org.apache.hadoop.hdfs.server.datanode.DataNode&rdquo;
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>Given this framework it is easier to implement complex logic to determine restart eligibility like rack awareness, restart greater than one node or a set percentage of nodes, restart based on the state of other services in the cluster etc. Also this can be used to implement rolling upgrades of software on cluster nodes. In short there are many options and use cases which can leverage this solution.</p>

<p>Quick word on handling failure during lock acquisition. When the node tries to acquire the lock and fails, the whole chef-client run process could have been stopped or waited for the lock to become available. Both of the options are not desirable as one could understand the implications. That being the reason for choosing the approach of waiting for sometime for the lock to become available and if not remember that the restart need to happen in the next chef-client run. This has the advantage of chef-client run further steps and be successful even when the particular service is not restarted and also automatically restart the service in the next chef-client run which seems like a balanced approach.</p>

<p>Note this solution uses the <code>zookeeper</code> ruby gem and the complete code can be found in the <a href="https://github.com/bloomberg/chef-bach/tree/master/cookbooks/bcpc-hadoop">chef-bach bcpc-hadoop cookbook</a>.</p>

<p>More notes on this category can be found <a href="http://blog.asquareb.com/blog/categories/chef/">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Restart of a Service Which Is Dependent on Multiple Services Through Chef]]></title>
    <link href="http://asquareb.github.io/blog/2015/02/28/restart-of-a-service-which-is-dependent-on-multiple-services-through-chef/"/>
    <updated>2015-02-28T23:07:47-04:00</updated>
    <id>http://asquareb.github.io/blog/2015/02/28/restart-of-a-service-which-is-dependent-on-multiple-services-through-chef</id>
    <content type="html"><![CDATA[<p>In a node there can be services that are dependent on other services. For e.g. a monitoring service is dependent on services which it monitors and collects data. So when a service being monitored is restarted, the service monitoring may have to be restarted to establish back the connections. This was the case with older version of JMXTrans which required a restart when any of the services it is monitoring got restarted. Assuming that the older version of JMXTrans is used to monitor various services running on a node how do we restart JMXTrans when any of the process is restarted while using <code>Chef</code> to manage the environment.</p>

<!--more-->


<p>First, the processes which need to be monitored can vary in each node and there can be one or many processes. Since Chef role determines the recipes which are run on a node, a default attribute can be added to define the services JMXTrans is dependent on. The following is an example</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;
</span><span class='line'>&ldquo;default_attributes&rdquo; : {
</span><span class='line'>   &ldquo;jmxtrans&rdquo;:{
</span><span class='line'>      &ldquo;servers&rdquo;:[
</span><span class='line'>                  {
</span><span class='line'>                    &ldquo;type&rdquo;: &ldquo;datanode&rdquo;,
</span><span class='line'>                    &ldquo;service&rdquo;: &ldquo;hadoop-hdfs-datanode&rdquo;,
</span><span class='line'>                    &ldquo;service_cmd&rdquo;: &ldquo;org.apache.hadoop.hdfs.server.datanode.DataNode&rdquo;
</span><span class='line'>                  },
</span><span class='line'>                  {
</span><span class='line'>                    &ldquo;type&rdquo;: &ldquo;hbase_rs&rdquo;,
</span><span class='line'>                    &ldquo;service&rdquo;: &ldquo;hbase-regionserver&rdquo;,
</span><span class='line'>                    &ldquo;service_cmd&rdquo;: “org.apache.hadoop.hbase.regionserver.HRegionServer"
</span><span class='line'>                  }
</span><span class='line'>                ]
</span><span class='line'>              } &hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>Here the <code>service</code> key defines the name of the service on which JMXTrans is dependent on. The <code>service_cmd</code> key stores a string which can uniquely identify the running process of the service. The <code>type</code> key is not relevant for this discussion. These attributes will change for each role based on which service is installed as part of the role.</p>

<p>Since JMXTRans need to be installed, configured and started on all the nodes to collect statistics from various services a recipe need to be created for the same. But the recipe can now take into account the new node attribute to build the JMXTrans restart logic. The following is a sample code snippet which shows how the logic can be built</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;
</span><span class='line'>jmx_services = Array.new&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>node[&lsquo;jmxtrans&rsquo;][&lsquo;servers&rsquo;].each do |server|
</span><span class='line'>  jmx_services.push(server[&lsquo;service&rsquo;])
</span><span class='line'>  jmx_srvc_cmds[server[&lsquo;service&rsquo;]] = server[&lsquo;service_cmd&rsquo;]
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>service &ldquo;restart jmxtrans on dependent service&rdquo; do
</span><span class='line'>  service_name &ldquo;jmxtrans&rdquo;
</span><span class='line'>  supports :restart => true, :status => true, :reload => true
</span><span class='line'>  action   :restart
</span><span class='line'>  #
</span><span class='line'>  # Create subcribes entries for each of the services on which JMXTrans is dependent on
</span><span class='line'>  #
</span><span class='line'>  jmx_services.each do |jmx_dep_service|
</span><span class='line'>    subscribes :restart, &ldquo;service[#{jmx_dep_service}]&rdquo;, :delayed
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>With the <code>subscribes</code> clause added to the <code>service</code> resource for every service JMXTrans is monitoring on the node, restarts of any of these services during <code>chef-client</code> run will make sure that JMXTrans service is restarted.</p>

<p>But what will happen if any of the dependent service is restarted externally for e.g. manually or upstart bounces a service. Then Chef will not restart JMXTrans during <code>chef-client</code> run since all the services are running. This will result in services restarted manually not being monitored by JMXTrans. The following is an updated code snippet which will handle this scenario. The complete recipe is available <a href="https://github.com/bloomberg/chef-bach/blob/master/cookbooks/bcpc_jmxtrans/recipes/default.rb">here</a>.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;
</span><span class='line'>jmx_services = Array.new
</span><span class='line'>jmx_srvc_cmds = Hash.new
</span><span class='line'>node[&lsquo;jmxtrans&rsquo;][&lsquo;servers&rsquo;].each do |server|
</span><span class='line'>  jmx_services.push(server[&lsquo;service&rsquo;])
</span><span class='line'>  jmx_srvc_cmds[server[&lsquo;service&rsquo;]] = server[&lsquo;service_cmd&rsquo;]
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>service &ldquo;restart jmxtrans on dependent service&rdquo; do
</span><span class='line'>  service_name &ldquo;jmxtrans&rdquo;
</span><span class='line'>  supports :restart => true, :status => true, :reload => true
</span><span class='line'>  action   :restart
</span><span class='line'>  jmx_services.each do |jmx_dep_service|
</span><span class='line'>    subscribes :restart, &ldquo;service[#{jmx_dep_service}]&rdquo;, :delayed
</span><span class='line'>  end
</span><span class='line'>  #
</span><span class='line'>  # To determine any of the service JMXTrans depends on is started after JMXTrans service
</span><span class='line'>  #
</span><span class='line'>  only_if {process_require_restart?(&ldquo;jmxtrans&rdquo;,&ldquo;jmxtrans-all.jar&rdquo;, jmx_srvc_cmds)}
</span><span class='line'>end
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>As you may have noticed there is a <code>only_if</code> condition calls a library function which takes in a hash of all the services and the string which identifies the service processes as the third paramter. The first two paramters passed are the JMXTrans service name and a string which can uniquely identify a running JMXTrans process.</p>

<p>The following is the code snippet of the library function and the complete code can be found <a href="https://github.com/bloomberg/chef-bach/blob/master/cookbooks/bcpc_jmxtrans/libraries/utils.rb">here</a>.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def process_require_restart?(process_name, process_cmd, dep_cmds)
</span><span class='line'>  tgt_proces_pid = &lt;code>pgrep -f #{process_cmd}&lt;/code>
</span><span class='line'>  &hellip;
</span><span class='line'>  #
</span><span class='line'>  # Find the start time of the JMXTrans process
</span><span class='line'>  #
</span><span class='line'>  tgt_proces_stime = &lt;code>ps --no-header -o start_time #{tgt_process_pid}&lt;/code>
</span><span class='line'>  &hellip;
</span><span class='line'>  ret = false
</span><span class='line'>  restarted_processes = Array.new
</span><span class='line'>  #
</span><span class='line'>  # Loop through the processess of all the dependent services
</span><span class='line'>  #
</span><span class='line'>  dep_cmds.each do |dep_process, dep_cmd|
</span><span class='line'>    dep_pids = &lt;code>pgrep -f #{dep_cmd}&lt;/code>
</span><span class='line'>    if dep_pids != &ldquo;&rdquo;
</span><span class='line'>      dep_pids_arr = dep_pids.split(&ldquo;\n&rdquo;)
</span><span class='line'>      dep_pids_arr.each do |dep_pid|
</span><span class='line'>        #
</span><span class='line'>        # Find the start time of a dependent process
</span><span class='line'>        #
</span><span class='line'>        dep_process_stime = &lt;code>ps --no-header -o start_time #{dep_pid}&lt;/code>
</span><span class='line'>        #
</span><span class='line'>        # If the dependent process start time is greater than JMXTrans start time
</span><span class='line'>        # set the return value to true
</span><span class='line'>        #
</span><span class='line'>        if DateTime.parse(tgt_proces_stime) &lt; DateTime.parse(dep_process_stime)
</span><span class='line'>          restarted_processes.push(dep_process)
</span><span class='line'>          ret = true
</span><span class='line'>        end
</span><span class='line'>  &hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>The logic behind the library function is to compare the start time of the JMXTrans process against the start time of processes of all the services it is dependent on. If any of the dependent processes start time is later than the start time of JMXTrans process then the JMXTrans service will get restarted.</p>

<p>It would be good to have a Chef primitive that can accomplish what the library function does so that similar situations can use it. Hope this provides a solution option to restart a service dependent on multiple services during a <code>chef-client</code> run.</p>

<p>More notes on this category can be found <a href="http://blog.asquareb.com/blog/categories/chef/">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamically Requesting a Common Service in a Chef Managed Environment]]></title>
    <link href="http://asquareb.github.io/blog/2015/02/21/dynamically-requesting-a-common-service-in-a-chef-managed-environment/"/>
    <updated>2015-02-21T22:39:48-04:00</updated>
    <id>http://asquareb.github.io/blog/2015/02/21/dynamically-requesting-a-common-service-in-a-chef-managed-environment</id>
    <content type="html"><![CDATA[<p>In a cluster environment there can be a common service running on all the nodes in the cluster which may be requested by an application using the cluster. For e.g. in a distributed computing environment logs can be created on each node in the cluster and a common service on each cluster node can be a service which regularly copies log entries into a common location. Copying of logs can be a requirement for some of the applications/services running on the cluster nodes so that users can go to one location to view the log data from all the nodes instead of looking at each node. This can also help with managing the security of the cluster by providing access to this common location instead of providing access to all the nodes in the cluster.</p>

<!-- more -->


<p>But copying of the logs may not be a requirement for some other service or application and the requirement may change in the future. It is better to build a solution so that the changes in the requirements to copy logs can be accommodated dynamically.</p>

<p>To explain the pattern on how we can accomplish the requirement, we will assume <code>Apache Flume</code> as the component which will be installed on all the nodes in the cluster and will be used to copy the log file entries to a common location in HDFS. The following is one solution to satisfy the requirement.</p>

<p>Create a new cookbook or reuse an existing cookbook which will be used on all the nodes in the cluster. Create a node attribute which will store a hash of hashes. For e.g.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default[&lsquo;bcpc&rsquo;][&lsquo;hadoop&rsquo;][&lsquo;copylog&rsquo;] = {}</span></code></pre></td></tr></table></div></figure></p>

<p>The following is the datastructure which will be used to populate the hash values to be stored in the attributes</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  &lsquo;app_id&rsquo; =>  { &lsquo;logfile&rsquo; => &ldquo;/path/file_name_of_log_file&rdquo;,
</span><span class='line'>                 &lsquo;docopy&rsquo; => true (or false)
</span><span class='line'>                },&hellip;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>where the <code>app_id</code> is an unique id of an application which requests the service to copy its logs, <code>logfile</code> is the path of the logfile and <code>docopy</code> is a flag to enable and disable the request to copy the log files based on change in need. If an application requests more than one logfile to be copied the <code>appli_id</code> need to be made unique with in the application by adding additonal details like log name or a sequence number.</p>

<p>When an application need to make a request to copy its log file, in the application&rsquo;s recipe, request can be added to the node attribute. For e.g. if logs from the nodes running <code>hbase-region-server</code> need to copy its logs to the common location, code similar to the following can be included in the recipe installing and starting the <code>hbase-region-server</code> service.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>node.default[&lsquo;bcpc&rsquo;][&lsquo;hadoop&rsquo;][&lsquo;copylog&rsquo;][&lsquo;hbase_regionserver_log&rsquo;] = {
</span><span class='line'>    &lsquo;logfile&rsquo; => &ldquo;/var/log/hbase/hbase-regionserver-#{node.hostname}.log&rdquo;,
</span><span class='line'>    &lsquo;docopy&rsquo; => true
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>node.default[&lsquo;bcpc&rsquo;][&lsquo;hadoop&rsquo;][&lsquo;copylog&rsquo;][&lsquo;hbase_regionserver_out&rsquo;] = {
</span><span class='line'>    &lsquo;logfile&rsquo; => &ldquo;/var/log/hbase/hbase-regionserver-#{node.hostname}.out&rdquo;,
</span><span class='line'>    &lsquo;docopy&rsquo; => true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>Note here how an unique identifier is used as the <code>app_id</code> for the two log files from <code>hbase_regionserver</code> to be copied to the common location in HDFS.</p>

<p>For someone not familiar with <code>Flume</code>, flume agents can be used to move data and they need a config file which defines things like the source, sink, the type of sink,the target location etc. Since <code>Flume</code> need to be installed in all nodes in the cluster to be a common service, a recipe need to be created to install the software. But when it comes to start <code>Flume agents</code>, the recipe need to loop through the node attribute to create required Flume configuration files for each logfile copy requests made by the applications running on the node.</p>

<p>For e.g if the node is running only <code>hbase_regionserver</code> there will be two copy requests in the attribute for which the recipe need to create Flume configuration files and start the corresponding <code>Flume agents</code>. If there are other applications/services running on the node for e.g. <code>HDFS Datanode</code> and if the recipes make copy requests then the number of flume configs and <code>flume agents</code> running on the node will be more. The following is the code snippet on how the <code>Flume</code> recipe can accomplish this</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;
</span><span class='line'>node[&lsquo;bcpc&rsquo;][&lsquo;hadoop&rsquo;][&lsquo;copylog&rsquo;].each do |id,f|
</span><span class='line'>   if f[&lsquo;docopy&rsquo;]
</span><span class='line'>     template &ldquo;/etc/flume/conf/flume-#{id}.conf&rdquo; do
</span><span class='line'>       source &ldquo;flume_flume-conf.erb”
</span><span class='line'>       action :create &hellip;
</span><span class='line'>       variables(:agent_name => &rdquo;#{id}&ldquo;,
</span><span class='line'>                 :log_location => &rdquo;#{f[&lsquo;logfile&rsquo;]}&ldquo; )
</span><span class='line'>       notifies :restart,"service[flume-agent-multi-#{id}]&rdquo;,:delayed
</span><span class='line'>     end
</span><span class='line'>     service &ldquo;flume-agent-multi-#{id}&rdquo; do
</span><span class='line'>       supports :status => true, :restart => true, :reload => false
</span><span class='line'>       service_name &ldquo;flume-agent-multi&rdquo;
</span><span class='line'>       action :start
</span><span class='line'>       start_command &ldquo;service flume-agent-multi start #{id}&rdquo;
</span><span class='line'>       restart_command &ldquo;service flume-agent-multi restart #{id}&rdquo;
</span><span class='line'>       status_command &ldquo;service flume-agent-multi status #{id}&rdquo;
</span><span class='line'>     end
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>A complete <code>Flume</code> recipe which includes this feature is available <a href="https://github.com/bloomberg/chef-bach/blob/master/cookbooks/bcpc-hadoop/recipes/copylog.rb">here</a>.</p>

<p>By default the init.d script for Flume starts one <code>Flume agent</code>. But BIGTOP jira <a href="https://issues.apache.org/jira/browse/BIGTOP-1581">BIGTOP-1581</a> provides an option to start/stop/restart flume agents by passing agent names as in the <code>service</code> resource in the previous code snippet. The name passed need to have a corresponding Flume config file under the configuration folder. Since <code>Flume</code> recipe need to know the copy request from all the applications running on the node, it should be the last recipe to be run on the node. This can be accomplished by creating a role to include the <code>Flume</code> recipe and add it to the end of chef-client runlist of all the nodes.</p>

<p>Hope this provides a solution option in a similar situation where applications can dynamically request for a common service in an environment. Also note that the data structure can be expanded so that applications can make richer requests for e.g. in this case request to change the location of the common location where logs are copied into etc.</p>

<p>More notes on this category can be found <a href="http://blog.asquareb.com/blog/categories/chef/">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Developing Chef Community Cookbook Which Allows Changing Execution Flow Dynamically]]></title>
    <link href="http://asquareb.github.io/blog/2014/11/19/developing-chef-community-cookbooks-which-allows-changing-execution-flow-dynamically/"/>
    <updated>2014-11-19T07:37:24-05:00</updated>
    <id>http://asquareb.github.io/blog/2014/11/19/developing-chef-community-cookbooks-which-allows-changing-execution-flow-dynamically</id>
    <content type="html"><![CDATA[<p>If you have been working on Chef you may already know that attributes and resources in recipes defined in a community cookbook can be modified. But there can be a need to allow users of community cookbook to be able to change the execution flow of recipes in the community cookbook. We will go over an approach using an example.</p>

<!-- more -->


<p>Consider a generic use case of a community cookbook which installs a service along with its configuration which can be modified by the user of the cookbook using a wrapper cookbook. When there is a change in the configuration the service need to be restarted so that the configuration can take in effect.
In a distributed compluting platform, multiple instances of a service is deployed in an environment/cluster for scalability and availability. When chef-client is run as daemon regularly which is typically the case in large clusters for cluster management, there is a possibility that auto run of chef-client on the nodes of the cluster can bring down and restart all the service instances at the same time so that the new configuration can take in effect. This can result in service outage which is not preferred. So there need to be some coordination which need to be implemented so that all instances of the service is not brought down at the same time and this will vary with each user using the community cookbook. If you are wondering about cases which matches this generic use cases, some of the distributed computing platform components like Apache HDFS, HBase, YARN, Kakfa, ZooKeeper are good examples.</p>

<p>Here is an approach to provide the flexibility for users to be able to incorporate the logic to coordinate the restart of the service so that all instances doesn&rsquo;t come down at the same time. We will use Kafka as an example. Kafka server gets deployed at multiple nodes to form a cluster so that it is highly available and scalable.</p>

<ul>
<li>Add a new attribute to the cookbook which defines the name of the recipe which should be used to coordinate start/restart of the service. For e.g. assuming Kafka as the cookbook name the attribute can be</li>
</ul>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default[:kafka][:start_coordination][:recipe] = &lt;code>kafka::_coordinate&lt;/code></span></code></pre></td></tr></table></div></figure>
- Instead of defining a service resource in a recipe in the cookbook to start/restart the Kafka service, create a new recipe called <code>_coordinate</code> similar to the following
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby_block &ldquo;coordinate_kafka_start&rdquo; do
</span><span class='line'>    block do
</span><span class='line'>      Chef::Log.debug (&ldquo;Default recipe to coordinate Kafka start is used&rdquo;)
</span><span class='line'>    end
</span><span class='line'>    action :create
</span><span class='line'>    notifies :restart, &lsquo;service[kafka]&rsquo;, :delayed
</span><span class='line'>  end
</span><span class='line'>  service &lsquo;kafka&rsquo; do
</span><span class='line'>    provider kafka_init_opts[:provider]
</span><span class='line'>    supports start: true, stop: true, restart: true, status: true
</span><span class='line'>    action [:enable, :start]
</span><span class='line'>  end</span></code></pre></td></tr></table></div></figure>
- Include this recipe at the location where you would have defined the service resource to start/restart Kafka. For e.g.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>include_recipe node.kafka.start_coordination.recipe</span></code></pre></td></tr></table></div></figure>
- Send all notifications normally targeted to the service resource like notifications from template resources for configuration changes, redirect it to the ruby_block resource in the <code>_coordinate</code> recipe with <code>:immediate</code> option.
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>notifies :create, &lsquo;ruby_block[coordinate_kafka_start]&rsquo;, :immediately</span></code></pre></td></tr></table></div></figure>
- This will make the community cookbook flexible enough for users to be able to include their logic to control the service restart process.</p>

<p>If you are an user who would want to use a community cookbook with similar option to overwrite the restart logic, the following is an approach on how to go about overwriting the default logic without making any modifications to the community cookbook.</p>

<ul>
<li><p>Assuming that you will be creating a cookbook (e.g. <code>use_community</code>) to use the community cookbook, add a new recipe to the cookbook similar to the following
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>ruby_block &ldquo;coordinate_kafka_start&rdquo; do
</span><span class='line'>  block do
</span><span class='line'>    Chef::Log.info (&ldquo; Custom recipe to coordinate Kafka start is used&rdquo;)
</span><span class='line'>  end
</span><span class='line'>  action :create
</span><span class='line'>  notifies :create, &lsquo;ruby_block[restart_coordination]&rsquo;, :delayed
</span><span class='line'>end
</span><span class='line'>ruby_block &ldquo;restart_coordination&rdquo; do
</span><span class='line'>  block do
</span><span class='line'>    Chef::Log.info (&ldquo;Need to implement the process to coordinate the restart process like using ZK&rdquo;)
</span><span class='line'>  end
</span><span class='line'>  action :nothing
</span><span class='line'>  notifies :restart, &lsquo;service[kafka]&rsquo;, :delayed
</span><span class='line'>end
</span><span class='line'>service &lsquo;kafka&rsquo; do
</span><span class='line'>  provider kafka_init_opts[:provider]
</span><span class='line'>  supports start: true, stop: true, restart: true, status: true
</span><span class='line'>  action [:enable, :start]
</span><span class='line'>end
</span><span class='line'>ruby_block &ldquo;restart_coordination_cleanup&rdquo; do
</span><span class='line'>   block do
</span><span class='line'>     Chef::Log.info (&ldquo;Implement any cleanup logic required after restart like releasing locks&rdquo;)
</span><span class='line'>   end
</span><span class='line'>   action :nothing
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>
Note that the first resource is the same as the default <code>_coordinate</code> recipe in the community cookbook and it is requirement so that notifcations are intercepted appropriately. Also the new cookbook should retain the service resource defined in the community <code>_coordinate</code> recipe.</p></li>
<li><p>Since all the restart notifications will be received by the <code>ruby_block[coordinate-kafka-start]</code> resource logic can be included in the new recipe as in the sample above.</p></li>
<li><p>Now we need to overwrite the community cookbook attribute value which stored the name of the recipe to be used for the start/restart process. It is easy as setting the attribute value in wrapper cookbook. In order to have the overwrite to take in effect, atleast one recipe from the wrapper cookbook should be included in the run list. This an be accomplished by creating a &ldquo;NOP&rdquo; recipe or a recipe which does the overwrite of the attribute and include it in the run list.</p></li>
<li><p>The following is an example of the content in the  recipe which over writes the attribute in the community cookbook
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>node.default.kafka.start_coordination.recipe = &lsquo;kafka-bcpc::coordinate&rsquo;</span></code></pre></td></tr></table></div></figure></p></li>
<li>Once this is done, update the role which installs the service with the recipe of the wrapper cookbook</li>
</ul>


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  &ldquo;name&rdquo;: &ldquo;Kafka-Server&rdquo;,
</span><span class='line'>  &ldquo;json_class&rdquo;: &ldquo;Chef::Role&rdquo;,
</span><span class='line'>  &ldquo;run_list&rdquo;: [
</span><span class='line'>    &ldquo;role[Basic]&rdquo;,
</span><span class='line'>    &hellip;
</span><span class='line'>    &ldquo;recipe[kafka-use-community::default]&rdquo;,
</span><span class='line'>    &ldquo;recipe[kafka-community::setattr]&rdquo;,
</span><span class='line'>    &hellip;
</span><span class='line'>  ],
</span><span class='line'>  &ldquo;description&rdquo;: &ldquo;Role to setup Kafka Server&rdquo;,
</span><span class='line'>  &hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>Even though the write-up is long, as you may have noted the idea is to simply use a notification interceptor <code>ruby_block</code> to pass control to the users of the community cookbook. In this case <code>ruby_block "coordinate_kafka_start"</code>.</p>

<p>The same technique can be used to change the behavior of other community cookbooks by the users of the cookbook. As with any framework the users of community cookbook need to know the notification interceptor <code>ruby_block</code> and the creator of the community cookbook should adhere to the framework strictly.</p>

<p> If you are looking for real world example,<a href="https://github.com/mthssdrbrg/kafka-cookbook/pull/63">Kafka community cookbook</a> is an example and the <a href="https://github.com/mthssdrbrg/kafka-cookbook/blob/master/README.md#controlling-restart-of-kafka-brokers-in-a-cluster">readme</a> provides the details about restart coordination.</p>

<p>Also if you are looking for other similar chef patterns and solutions using chef, come join us at <a href="http://sched.co/2HtF">ChefConf 2015</a>.</p>

<p>More notes on this category can be found <a href="http://blog.asquareb.com/blog/categories/chef/">here</a>.</p>
]]></content>
  </entry>
  
</feed>
