<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Chef | Quick Notes]]></title>
  <link href="http://asquareb.github.io/blog/categories/chef/atom.xml" rel="self"/>
  <link href="http://asquareb.github.io/"/>
  <updated>2022-02-07T14:51:51-08:00</updated>
  <id>http://asquareb.github.io/</id>
  <author>
    <name><![CDATA[asquareb]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Chef HWRP Using an Example]]></title>
    <link href="http://asquareb.github.io/blog/2015/04/23/chef-hwrp-using-an-example/"/>
    <updated>2015-04-23T23:34:17-04:00</updated>
    <id>http://asquareb.github.io/blog/2015/04/23/chef-hwrp-using-an-example</id>
    <content type="html"><![CDATA[<p>Heavy Weight Resource Provider (HWRP) is one of the options Chef offers to create custom resources and the other being <a href="http://blog.asquareb.com/blog/2015/04/19/chef-lwrp-using-hdfs-directory-as-an-example/">LWRP</a>. It would be good to read the notes on <a href="http://blog.asquareb.com/blog/2015/04/19/chef-lwrp-using-hdfs-directory-as-an-example/">LWRP</a> to understand the context and the difference between <code>LWRP</code> and <code>HWRP</code>.</p>

<p>Similar to LWRP, HWRP requires a resource definition and the corresponding provider. The key difference is that there are no DSL in the HWRP as in LWRP and everything is coded in <code>Ruby</code> code. So taking the same example of HDFS directory resource used in the notes on LWRP, the following is the skeleton of the resource definition.</p>

<!-- more -->


<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>class Chef
</span><span class='line'>  class Resource
</span><span class='line'>    class HdfsDir &lt; Chef::Resource&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>  #
</span><span class='line'>  # What provider this resource provides
</span><span class='line'>  #
</span><span class='line'>  provides :hdfsdir
</span><span class='line'>
</span><span class='line'>  def initialize(name, run_context=nil)
</span><span class='line'>    super
</span><span class='line'>
</span><span class='line'>    #
</span><span class='line'>    # Set the resource name
</span><span class='line'>    #
</span><span class='line'>    @resource_name = :hdfsdir
</span><span class='line'>
</span><span class='line'>    #
</span><span class='line'>    # Allowed actions in this resource
</span><span class='line'>    #
</span><span class='line'>    @allowed_actions = [:create, :delete, :chown, :chmod, :rename, :chgrp, :nothing]
</span><span class='line'>
</span><span class='line'>    #
</span><span class='line'>    # Default action if none specified when using the resource
</span><span class='line'>    #
</span><span class='line'>    @action = :create
</span><span class='line'>
</span><span class='line'>    #
</span><span class='line'>    # Set default values for resource attributes
</span><span class='line'>    #
</span><span class='line'>    @path = name
</span><span class='line'>    @namenode = nil
</span><span class='line'>    ...
</span><span class='line'>  end
</span><span class='line'>
</span><span class='line'>  #
</span><span class='line'>  # Methods to get/set attributes and define additional characteristics
</span><span class='line'>  #
</span><span class='line'>  def path(arg=nil)
</span><span class='line'>    set_or_return(:path, arg, :kind_of =&gt; String, :required =&gt; true)
</span><span class='line'>  end
</span><span class='line'>
</span><span class='line'>  def namenode(arg=nil)
</span><span class='line'>    set_or_return(:namenode, arg, :kind_of =&gt; String, :required =&gt; true)
</span><span class='line'>  end
</span><span class='line'>
</span><span class='line'>  ...
</span><span class='line'>
</span><span class='line'>end
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>The HWRP is a <code>Ruby</code> class in this case <code>HdfsDir</code> which is a subclass of <code>Chef::Resource</code> class. The <code>provides</code> method specifies the resource provider for this resource and in this case it is <code>hdfsdir</code>.</p>

<p>As in any <code>Ruby</code> class, the <code>initialize</code> method is used perform initializations like setting initial values of variables. In this case the pre-defined instance variable <code>resource_name</code> is set to a name which can be used to create a resource block in recipes using this HWRP. An array of symbols specifying the supported <code>actions</code> supported by this HWRP is assigned to the instance variable <code>allowed_actions</code>. A default action which will be taken if an <code>action</code> is not set for while creating a resource using this HWRP (in this case <code>create</code>) is set to the instance variable <code>action</code>.</p>

<p>The remaining section in the skeleton is to define the characteristics of all the attributes of this resource which is similar to the attribute definition in LWRP. The key difference is that they are all defined as <code>Ruby</code> methods and the <code>set_or_return</code> is similar to <code>Ruby</code> <code>attr_accessor</code> method which creates the getters and setters for the attributes.</p>

<p>Unlike LWRP, the HWRP resource and provider code is stored in files under the <code>libraries</code> directory of the cookbook. Also there is no strict rules about the file naming conventions since these are <code>Ruby</code> classes and they get loaded first during the <code>Chef client</code> run.</p>

<p>Now lets turn to the corresponding provider definition and the following is the skeleton. It is more or less similar to the LWRP provider code we had seen earlier with some differences.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require &lsquo;chef/log&rsquo;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>class Chef
</span><span class='line'>  class Provider
</span><span class='line'>    class HdfsDir &lt; Chef::Provider&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>  #
</span><span class='line'>  # To enable -W/--why-run option of chef-client
</span><span class='line'>  #
</span><span class='line'>  def whyrun_supported?
</span><span class='line'>     true
</span><span class='line'>  end
</span><span class='line'>
</span><span class='line'>  #
</span><span class='line'>  # Method automatically called by Chef during the client execution phase
</span><span class='line'>  # Can be used to initialize variables and also verify the current state
</span><span class='line'>  #
</span><span class='line'>  def load_current_resource
</span><span class='line'>    require 'webhdfs'
</span><span class='line'>
</span><span class='line'>    new_resource.user == nil ? @user = ENV['USER'] : @user = new_resource.user
</span><span class='line'>    nnaddress = new_resource.namenode
</span><span class='line'>    nnport = new_resource.nnport
</span><span class='line'>    @client = WebHDFS::Client.new(nnaddress,nnport,@user)
</span><span class='line'>    if (!validnn?())
</span><span class='line'>      raise RuntimeError, "Invalid namenode provided or HDFS not available"
</span><span class='line'>    end
</span><span class='line'>    @omode = new_resource.mode
</span><span class='line'>    new_resource.mode == nil ? @mode = "0750" : @mode = new_resource.mode
</span><span class='line'>    @path = new_resource.path
</span><span class='line'>    @tpath = new_resource.tpath
</span><span class='line'>    @tgroup = new_resource.tgroup
</span><span class='line'>    @tuser = new_resource.tuser
</span><span class='line'>  end
</span><span class='line'>
</span><span class='line'>  ...
</span><span class='line'>  #
</span><span class='line'>  # Action to create a directory in HDFS
</span><span class='line'>  #
</span><span class='line'>  def action_create
</span><span class='line'>    if (dir_exists?(@path))
</span><span class='line'>      Chef::Log::info("Directory #{ @path } exits; create action not taken")
</span><span class='line'>    else
</span><span class='line'>      converge_by("Create #{ @new_resource }") do
</span><span class='line'>        @client.mkdir(@path,'permission' =&gt; @mode)
</span><span class='line'>      end
</span><span class='line'>      new_resource.updated_by_last_action(true)
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>…
</span><span class='line'>  #
</span><span class='line'>  # Method to check whether the namenode provided is valid
</span><span class='line'>  #
</span><span class='line'>  def validnn?()
</span><span class='line'>    return dir_exists?("/") ? true : false
</span><span class='line'>  end
</span><span class='line'>  ...
</span><span class='line'>end
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>As with the resource definition, the provider is also a <code>Ruby</code> class which is a subclass of <code>Chef::Provider</code> class. The method <code>whyrun_supported</code> is to specify whether the resource supports the <code>chef client</code> run with <code>why-run</code> option. If this method is set to return <code>true</code>, then the strings provided in the <code>converge_by</code> statement of the <code>action</code> requested in the recipe will be logged instead of performing the actual convergence of the resource.</p>

<p><code>load_current_resource</code> method need to be overwritten in an HWRP which is optional in as LWRP. As discussed in the LWRP note, this method can be used to check the current state of the resource.</p>

<p>The methods for the <code>actions</code> supported are defined using the naming convention <code>action_name</code>. For e.g. for the <code>create</code> action the method name is <code>action_create</code>. Supporting methods can be defined as in any <code>Ruby</code> class for e.g. in this case `validnn??`` method.</p>

<p>The method <code>new_resource.updated_by_last_action</code> is called with a value of <code>true</code> so that <code>Chef</code> is notified that the resource got updated by that particular <code>action</code>.</p>

<p>More notes in this category can be found <a href="http://blog.asquareb.com/blog/categories/chef/">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chef LWRP Using HDFS Directory as an Example]]></title>
    <link href="http://asquareb.github.io/blog/2015/04/19/chef-lwrp-using-hdfs-directory-as-an-example/"/>
    <updated>2015-04-19T22:48:58-04:00</updated>
    <id>http://asquareb.github.io/blog/2015/04/19/chef-lwrp-using-hdfs-directory-as-an-example</id>
    <content type="html"><![CDATA[<p><code>Chef</code> provides a large set of <code>resources</code> to work with. But there are situations where  resources provided by <code>Chef</code> may not be sufficient. For e.g, distributed file systems can’t be handled by the file system related resources (<code>file</code>, <code>directory</code> etc) which comes out of the box with <code>Chef</code>. Being flexible and customizable, <code>Chef</code> provides two options (LWRP, HWRP) for users to create their own resources.</p>

<!-- more -->


<p>Light Weight Resource Providers (LWRP) use DSL to simplify the creation of resources and are used when existing chef <code>resources</code> can be leveraged with minimal <code>Ruby</code> code. In contrast, Heavy Weight Resource Providers (HWRP) are used when existing resources can’t be leveraged and <code>Ruby</code> code need to be used to implement the resource provider.</p>

<p>Lets quickly look at a LWRP using HDFS (which is a distributed file system) directory resource as an example. A LWRP is created and stored in a cookbook and there are two parts to it. First the resource definition which defines the actions supported and attributes accepted by the LWRP. The resource definition resides in the <code>resources</code> directory of the cookbook. The second part is the provider or simply the code which implements the actions supported by the LWRP. The provider is stored in the <code>provider</code> directory of the cookbook in which the LWRP is being created.</p>

<p>For <code>chef</code> to be able to identify the new resource, the file name of the resource definition and the provider file need to have the same name. For e.g. lets assume that the HDFS directory resource is created in hdfs cookbook and the resource is named hdfsdir, the following will be the cookbook directory structure (showing only the required directories)</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>hdfs
</span><span class='line'>  |&lt;strong>&lt;strong>&lt;em> providers
</span><span class='line'>  |             |&lt;/em>&lt;/strong>&lt;/strong>&lt;strong>&lt;em> hdfsdir.rb      &lt;br/>
</span><span class='line'>  |
</span><span class='line'>  |&lt;/em>&lt;/strong>&lt;strong> Resources
</span><span class='line'>                |&lt;/strong>______ hdfsdir.rb&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>When the resource need to be used in a <code>recipe</code>, the resource need to be prefixed with the cookbook name separated by an “_” (underscore).  For e.g.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>hdfs_hdfsdir “/tmp/pass” do
</span><span class='line'>  action :delete
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>Lets look at the LWRP <code>resource</code> definition for HDFS directory resource</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>actions :create, :delete, :chown, :chmod, :rename, :chgrp
</span><span class='line'>default_action :create
</span><span class='line'>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>fqdn or ip address of the name node server&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>#
</span><span class='line'>attribute :namenode, :kind_of => String, :required => true
</span><span class='line'>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>port number of the namenode&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>#
</span><span class='line'>attribute :nnport, :kind_of => String, :required => true
</span><span class='line'>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>Directory path on which actions need to be taken&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>#
</span><span class='line'>attribute :path, :kind_of => String, :name_attribute => true, :required => true
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure></p>

<p><code>actions</code> defines the actions supported by the new resource.</p>

<p><code>default_action</code> defines the action when the resource is used in an recipe and no action clause is specified in the recipe.</p>

<p><code>attribute</code> defines each attribute which can be set when using the resource. It also defines whether the attribute is required and the attribute type.</p>

<p>One <code>attribute</code> can take the <code>name</code> value of the resource if it is not set explicitly in the recipe and in this case the <code>attribute</code> path takes the name value of the resource and it is specified using <code>:name_attribute =&gt; true</code>. The complete definition can be found <a href="https://github.com/bijugs/simple-scripts/blob/master/hdfsdir_resource.rb">here</a>.</p>

<p>With the <code>resource</code> definition out of the way lets look at the <code>provider</code> for the hdfs directory resource. The following is the code skeleton for the provider and the full code can be found <a href="https://github.com/bijugs/simple-scripts/blob/master/hdfsdir_provider.rb">here</a>.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>require &lsquo;chef/log&rsquo;
</span><span class='line'>require &lsquo;webhdfs&rsquo;
</span><span class='line'>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>#
</span><span class='line'>use_inline_resources
</span><span class='line'>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>To enable -W/&ndash;why-run option of chef-client&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>#
</span><span class='line'>def whyrun_supported?
</span><span class='line'>   true
</span><span class='line'>end
</span><span class='line'>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>Method automatically called by Chef during the client execution phase&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>Can be used to initialize variables and also verify the current state&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>#
</span><span class='line'>def load_current_resource
</span><span class='line'>   @current_resource = Chef::Resource::HdfsHdfsdir.new(new_resource.name)
</span><span class='line'>   new_resource.user == nil ? @current_resource.user = ENV[&lsquo;USER&rsquo;] : @current_resource.user = new_resource.user&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>&hellip;
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>action :create do
</span><span class='line'>  if (dir_exists?(@path))
</span><span class='line'>    Chef::Log::info(&ldquo;Directory #{ @path } exits; create action not taken&rdquo;)
</span><span class='line'>  else
</span><span class='line'>    converge_by(&ldquo;Create #{ @new_resource }&rdquo;) do
</span><span class='line'>      @client.mkdir(@path,&lsquo;permission&rsquo; => @mode)
</span><span class='line'>    end
</span><span class='line'>    new_resource.updated_by_last_action(true)
</span><span class='line'>  end
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>action :delete do
</span><span class='line'>&hellip;
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>&hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>The <code>require</code> method is used to include external files as in any Ruby code. Note that <code>webhdfs</code> gem need to installed for this code to work.</p>

<p> <code>use_inline_resources</code> is a must for LWRP. The reason is to make sure that any <code>notifications</code> raised from any of the resources in the LWRP (remember LWRP can leverage other Chef resources to implement its functionality) will be treated as being raised by the LWRP resource collection as a whole and not the individual resource within the LWRP resource which is raising the notification.</p>

<p><code>new_resource</code> instance object is automatically created when the resource is used and the attribute values in the new object is set to the values passed from the recipe that is using the resource.</p>

<p>When creating resources one of the key requirement is to make sure that it is <strong>idempotent</strong>. This requires the current state of the resource to be known. For this <code>chef</code> provides an empty method <code>load_current_resource</code> which can be overwritten by the resource provider. Since this method will be the first to be called when the resource is used in a recipe, the method call can be used to check the current state of the resource. For e.g. if the directory resource is already existing and the resource action is to <code>create</code> the directory, the resource provider can skip the requested action since the directory is up to date. For anyone interested in more details look into the code for <a href="https://github.com/chef/chef/blob/24c3387634f32f27f63d388ddbf64004e17c311b/lib/chef/provider/lwrp_base.rb">LWRPBase class</a> which is the parent for the LWRP provider.</p>

<p>The remaining sections in the code skeleton are to implement the actions supported by the resource. They can use the existing <code>chef</code> resources and/or use Ruby code. If you had a chance to look at the complete code for <a href="https://github.com/bijugs/simple-scripts/blob/master/hdfsdir_provider.rb">hdfsdir provider</a> contrary to how LWRP is meant to be implemented, the code doesn’t use any existing <code>chef</code> resource since there is none for a distributed file system like HDFS and all the actions had to be implemented using <code>Ruby</code>. But to understand the various aspects of writing an LWRP it is still helpful.</p>

<p><code>whyrun_supported?</code> method is used to enable/disable support for the <code>--why-run</code> option of <code>chef-client</code> by setting the return value to <code>true</code> or <code>false</code>.</p>

<p>When <code>whyrun_supported?</code> is set to <code>true</code> and if <code>chef-client</code> run uses <code>--why-run</code> option the string passed to  <code>converge_by</code> clause will be logged instead of actual convergence.</p>

<p>When an action is taken on a resource <code>new_resource.updated_by_last_action(true)</code> is used to notify <code>chef</code> that the resource was updated by the requested action.</p>

<p>Finally, note that you can use the hdfs LWRP code used in this example if you are dealing with HDFS by renaming the files and copying into the resources and provider directories of your cookbook.</p>

<p>More notes on this category can be found <a href="http://blog.asquareb.com/blog/categories/chef/">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Integrating Chef and Apache ZooKeeper for Coordination in a Cluster]]></title>
    <link href="http://asquareb.github.io/blog/2015/04/03/integrating-chef-and-apache-zookeeper-for-coordination-in-a-cluster/"/>
    <updated>2015-04-03T23:36:21-04:00</updated>
    <id>http://asquareb.github.io/blog/2015/04/03/integrating-chef-and-apache-zookeeper-for-coordination-in-a-cluster</id>
    <content type="html"><![CDATA[<p>In a cluster environment services on nodes may have to be coordinated for various reasons. For e.g., when a configuration change is made to a distributed computing component like <code>HDFS</code>, the <code>HDFS</code> service on all nodes shouldn&rsquo;t stop at the same time to restart so that the configuration takes in effect. Stopping of the service on all the nodes will end up in unavailability which is not desired to put it lightly.</p>

<p>There are many options to perform orchestration/coordination with varied maturity when you manage a cluster using <code>Chef</code>. Here we look at how <code>Chef</code> and <code>ZooKeeper</code> can work together to perform coordination of services on cluster nodes. We will use the need to control and coordinate service restart so that the service in all nodes are not stopped at the same time as the example to explain the solution.</p>

<!--more-->


<p>Lets take the simple case of service restart where only one instance of the service can be restarted at any time. One of the ways to accomplish this is by forcing nodes to acquire a lock to perform service restarts. The following is the solution summary</p>

<ul>
<li>A lock need to be acquired by a node before it can take a restart action on the service instance running on the node.</li>
<li>When a node tries to acquire a lock and if it fails since some other node is holding the lock or other reasons, the node waits and retries for a certain time.</li>
<li>If the lock is acquired within the certain prescribed time, the node restarts the service.</li>
<li>Once the restart is complete the node releases the lock so that other nodes can take a lock on it.</li>
<li>If the lock is not acquired within the certain time, the node remembers that the restart was not successful and hence will try to restart the service next time chef client runs on the node.</li>
</ul>


<p>If there are any misconfigurations which triggered the restart, the service will not be successfully restarted due to the misconfiguration on the node which acquired the lock first. Since the restart process failed, lock will not be released resulting in other nodes not being able to able to acquire it. This prevents misconfiguration being propagated to other nodes preventing unavailability. Also until the misconfiguration is corrected the service will not be restarted in all the nodes.</p>

<p>Now the key is to be able to implement lock primitive in a distributed environment and this is where <a href="https://zookeeper.apache.org/">Apache ZooKeeper</a> comes into play. <code>ZooKeeper</code> is a high-performance coordination service which among many things provides synchronization for distributed applications. <code>ZooKeeper</code> is used by many Apache projects like <code>HBase</code> which is a distributed scalable data store. <code>ZooKeeper</code> is also a distributed system which means failover is handled automatically preventing unavailability.</p>

<p>For the use case of allowing only one node to restart a service, we can use ZooKeeper “znode” as the lock. For a service “X”, if a node is able to create a znode “X” in ZooKeeper then the service can be restarted by the node. If a node is not able to create znode “X” since the znode is already created by another node in the cluster or other reasons, then the node need to wait until the znode is removed.</p>

<p>The following is a Chef <a href="https://github.com/bijugs/chef-bach/blob/master_rolling_restart/cookbooks/bcpc-hadoop/definitions/hadoop_service.rb"><code>definition</code></a> which implements the restart coordination logic. It is implemented as a <code>definition</code> so that it can be used to coordinate the restart of multiple services in a cluster. The inline comments in the code explains the logic and any reference to hadoop can be discarded since this can be used for any service. Currently this is implemented and used for a hadoop cluster.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
<span class='line-number'>108</span>
<span class='line-number'>109</span>
<span class='line-number'>110</span>
<span class='line-number'>111</span>
<span class='line-number'>112</span>
<span class='line-number'>113</span>
<span class='line-number'>114</span>
<span class='line-number'>115</span>
<span class='line-number'>116</span>
<span class='line-number'>117</span>
<span class='line-number'>118</span>
<span class='line-number'>119</span>
<span class='line-number'>120</span>
<span class='line-number'>121</span>
<span class='line-number'>122</span>
<span class='line-number'>123</span>
<span class='line-number'>124</span>
<span class='line-number'>125</span>
<span class='line-number'>126</span>
<span class='line-number'>127</span>
<span class='line-number'>128</span>
<span class='line-number'>129</span>
<span class='line-number'>130</span>
<span class='line-number'>131</span>
<span class='line-number'>132</span>
<span class='line-number'>133</span>
<span class='line-number'>134</span>
<span class='line-number'>135</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;h1>Definition takes three parameters&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>service_name: Name of the service&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>dependencies: Resources typically template resources for which the service need to be restarted&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;h1>process_identifier: String which identifies the process of the service&lt;/h1>
</span><span class='line'>
</span><span class='line'>&lt;p>#
</span><span class='line'>define :hadoop_service, :service_name => nil, :dependencies => nil, :process_identifier => nil do&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>  params[:service_name] ||= params[:name]
</span><span class='line'>  #
</span><span class='line'>  # Service resource defined using the parameters passed
</span><span class='line'>  #
</span><span class='line'>  service &ldquo;#{params[:service_name]}&rdquo; do
</span><span class='line'>    supports :status => true, :restart => true, :reload => false
</span><span class='line'>    action [:enable, :start]
</span><span class='line'>  end
</span><span class='line'>  #
</span><span class='line'>  # Checking to see whether user requested to not to use restart coordination
</span><span class='line'>  #
</span><span class='line'>  if node[&ldquo;bcpc&rdquo;][&ldquo;hadoop&rdquo;][&ldquo;skip_restart_coordination&rdquo;]
</span><span class='line'>    Chef::Log.info &ldquo;Coordination of #{params[:service_name]} restart will be skipped as per user request.&rdquo;
</span><span class='line'>    begin
</span><span class='line'>      res = resources(service: &ldquo;#{params[:service_name]}&rdquo;)
</span><span class='line'>      if params[:dependencies]
</span><span class='line'>        params[:dependencies].each do |dep|
</span><span class='line'>          res.subscribes(:restart, &ldquo;#{dep}&rdquo;, :delayed)
</span><span class='line'>        end
</span><span class='line'>      end
</span><span class='line'>    rescue Chef::Exceptions::ResourceNotFound
</span><span class='line'>      Chef::Log.info(&ldquo;Resource service #{params[:service_name]} not found&rdquo;)
</span><span class='line'>    end
</span><span class='line'>  else
</span><span class='line'>    if !params[:process_identifier]
</span><span class='line'>      Chef::Application.fatal!(&ldquo;hadoop_service for #{params[:service_name]} need to specify a valid value for the parameter :process_identifier&rdquo;)
</span><span class='line'>    end
</span><span class='line'>    #
</span><span class='line'>    # When there is a need to restart a hadoop service, a lock need to be taken so that the restart is sequenced preventing all nodes being down at the sametime
</span><span class='line'>    # If there is a failure in acquiring a lock with in a certian period, the restart is scheduled for the next run on chef-client on the node.
</span><span class='line'>    # To determine whether the prev restart failed is the node attribute node[:bcpc][:hadoop][:service_name][:restart_failed] is set to true
</span><span class='line'>    # This ruby block is to check whether this node attribute is set to true and if it is set then gets the hadoop service restart process in motion.
</span><span class='line'>    #
</span><span class='line'>    ruby_block &ldquo;handle_prev&lt;em>#{params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;/em>&rsquo;)}&lt;em>restart_failure&rdquo; do
</span><span class='line'>      block do
</span><span class='line'>        Chef::Log.info &ldquo;Need to restart #{params[:service_name]} since it failed during the previous run. Another node&rsquo;s restart process failure is a possible reason&rdquo;
</span><span class='line'>      end
</span><span class='line'>      action :create
</span><span class='line'>      only_if { node[:bcpc][:hadoop][params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;/em>&rsquo;).to_sym][:restart_failed] and
</span><span class='line'>              !process_restarted_after_failure?(node[:bcpc][:hadoop][params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;em>&rsquo;).to_sym][:restart_failed_time],&ldquo;#{params[:process_identifier]}&rdquo;)}
</span><span class='line'>    end
</span><span class='line'>    #
</span><span class='line'>    # Since string with all the zookeeper nodes is used multiple times this variable is populated once and reused reducing calls to Chef server
</span><span class='line'>    #
</span><span class='line'>    zk_hosts = (get_node_attributes(MGMT_IP_ATTR_SRCH_KEYS,&ldquo;zookeeper_server&rdquo;,&ldquo;bcpc-hadoop&rdquo;).map{|zkhost| &ldquo;#{zkhost[&lsquo;mgmt_ip&rsquo;]}:#{node[:bcpc][:hadoop][:zookeeper][:port]}&rdquo;}).join(&ldquo;,&rdquo;)
</span><span class='line'>    #
</span><span class='line'>    # znode is used as the locking mechnism to control restart of services. The following code is to build the path
</span><span class='line'>    # to create the znode before initiating the restart of hadoop service
</span><span class='line'>    #
</span><span class='line'>    lock_znode_path = format_restart_lock_path(node[:bcpc][:hadoop][:restart_lock][:root],&ldquo;#{params[:service_name]}&rdquo;)
</span><span class='line'>    #
</span><span class='line'>    # All hadoop service restart situations like changes in config files or restart due to previous failures invokes this ruby_block
</span><span class='line'>    # This ruby block tries to acquire a lock and if not able to acquire the lock, sets the restart_failed node attribute to true
</span><span class='line'>    #
</span><span class='line'>    ruby_block &ldquo;acquire_lock_to_restart&lt;/em>#{params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;em>&rsquo;)}&rdquo; do
</span><span class='line'>      require &lsquo;time&rsquo;
</span><span class='line'>      block do
</span><span class='line'>        tries = 0
</span><span class='line'>        Chef::Log.info(&ldquo;#{node[:hostname]}: Acquring lock at #{lock_znode_path}&rdquo;)
</span><span class='line'>        while true
</span><span class='line'>          lock = acquire_restart_lock(lock_znode_path, zk_hosts, node[:fqdn])
</span><span class='line'>          if lock
</span><span class='line'>            break
</span><span class='line'>          else
</span><span class='line'>            tries += 1
</span><span class='line'>            if tries >= node[:bcpc][:hadoop][:restart_lock_acquire][:max_tries]
</span><span class='line'>              failure_time = Time.now().to_s
</span><span class='line'>              Chef::Log.info(&ldquo;Couldn&rsquo;t acquire lock to restart &rdquo;)
</span><span class='line'>              node.set[:bcpc][:hadoop][params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;/em>&rsquo;).to_sym][:restart_failed] = true
</span><span class='line'>              node.set[:bcpc][:hadoop][params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;em>&rsquo;).to_sym][:restart_failed_time] = failure_time
</span><span class='line'>              node.save
</span><span class='line'>              break
</span><span class='line'>            end
</span><span class='line'>            sleep(node[:bcpc][:hadoop][:restart_lock_acquire][:sleep_time])
</span><span class='line'>          end
</span><span class='line'>        end
</span><span class='line'>      end
</span><span class='line'>      action :nothing
</span><span class='line'>      if params[:dependencies]
</span><span class='line'>        params[:dependencies].each do |dep|
</span><span class='line'>          subscribes :create, &ldquo;#{dep}&rdquo;, :immediate
</span><span class='line'>        end
</span><span class='line'>      end
</span><span class='line'>      subscribes :create, &ldquo;ruby_block[handle_prev&lt;/em>#{params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;em>&rsquo;)}&lt;/em>restart_failure]&rdquo;, :immediate
</span><span class='line'>    end
</span><span class='line'>    #
</span><span class='line'>    # If lock is acquired by the node, ruby_block executes which is to notify service to restart
</span><span class='line'>    #
</span><span class='line'>    ruby_block &ldquo;coordinate&lt;em>#{params[:service_name].gsub(&lsquo;-&rsquo;,&lsquo;&lt;/em>&rsquo;)}_restart&rdquo; do
</span><span class='line'>      block do
</span><span class='line'>        Chef::Log.info(&ldquo;Data node will be restarted in node #{node[:fqdn]}&rdquo;)
</span><span class='line'>      end
</span><span class='line'>      action :create
</span><span class='line'>      only_if { my_restart_lock?(lock_znode_path, zk_hosts, node[:fqdn]) }
</span><span class='line'>    end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>begin
</span><span class='line'>  res = resources(service: "#{params[:service_name]}")
</span><span class='line'>  res.subscribes(:restart, "ruby_block[coordinate_#{params[:service_name].gsub('-','_')}_restart]", :immediate)
</span><span class='line'>rescue Chef::Exceptions::ResourceNotFound
</span><span class='line'>  Chef::Log.info("Resource service #{params[:service_name]} not found")
</span><span class='line'>end
</span><span class='line'>#
</span><span class='line'># Once the service restart is complete, the following block releases the lock 
</span><span class='line'>#
</span><span class='line'>ruby_block "release_#{params[:service_name].gsub('-','_')}_restart_lock" do
</span><span class='line'>  block do
</span><span class='line'>    Chef::Log.info("#{node[:hostname]}: Releasing lock at #{lock_znode_path}")
</span><span class='line'>    lock_rel = rel_restart_lock(lock_znode_path, zk_hosts, node[:fqdn])
</span><span class='line'>    if lock_rel
</span><span class='line'>      node.set[:bcpc][:hadoop][params[:service_name].gsub('-','_').to_sym][:restart_failed] = false
</span><span class='line'>      node.save
</span><span class='line'>    end
</span><span class='line'>  end
</span><span class='line'>  action :create
</span><span class='line'>  only_if { my_restart_lock?(lock_znode_path, zk_hosts, node[:fqdn]) }
</span><span class='line'>end
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>  end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></p>

<p>The following code snippet is how it is used in recipes instead of the default Chef <code>service</code> resource.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;
</span><span class='line'>dep = [&ldquo;template[/etc/hadoop/conf/hdfs-site.xml]&rdquo;,
</span><span class='line'>       &ldquo;template[/etc/hadoop/conf/hadoop-env.sh]&rdquo;]&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>hadoop_service &ldquo;hadoop-hdfs-datanode&rdquo; do
</span><span class='line'>  dependencies dep
</span><span class='line'>  process_identifier &ldquo;org.apache.hadoop.hdfs.server.datanode.DataNode&rdquo;
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure></p>

<p>Given this framework it is easier to implement complex logic to determine restart eligibility like rack awareness, restart greater than one node or a set percentage of nodes, restart based on the state of other services in the cluster etc. Also this can be used to implement rolling upgrades of software on cluster nodes. In short there are many options and use cases which can leverage this solution.</p>

<p>Quick word on handling failure during lock acquisition. When the node tries to acquire the lock and fails, the whole chef-client run process could have been stopped or waited for the lock to become available. Both of the options are not desirable as one could understand the implications. That being the reason for choosing the approach of waiting for sometime for the lock to become available and if not remember that the restart need to happen in the next chef-client run. This has the advantage of chef-client run further steps and be successful even when the particular service is not restarted and also automatically restart the service in the next chef-client run which seems like a balanced approach.</p>

<p>Note this solution uses the <code>zookeeper</code> ruby gem and the complete code can be found in the <a href="https://github.com/bloomberg/chef-bach/tree/master/cookbooks/bcpc-hadoop">chef-bach bcpc-hadoop cookbook</a>.</p>

<p>More notes on this category can be found <a href="http://blog.asquareb.com/blog/categories/chef/">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Restart of a Service Which Is Dependent on Multiple Services Through Chef]]></title>
    <link href="http://asquareb.github.io/blog/2015/02/28/restart-of-a-service-which-is-dependent-on-multiple-services-through-chef/"/>
    <updated>2015-02-28T23:07:47-04:00</updated>
    <id>http://asquareb.github.io/blog/2015/02/28/restart-of-a-service-which-is-dependent-on-multiple-services-through-chef</id>
    <content type="html"><![CDATA[<p>In a node there can be services that are dependent on other services. For e.g. a monitoring service is dependent on services which it monitors and collects data. So when a service being monitored is restarted, the service monitoring may have to be restarted to establish back the connections. This was the case with older version of JMXTrans which required a restart when any of the services it is monitoring got restarted. Assuming that the older version of JMXTrans is used to monitor various services running on a node how do we restart JMXTrans when any of the process is restarted while using <code>Chef</code> to manage the environment.</p>

<!--more-->


<p>First, the processes which need to be monitored can vary in each node and there can be one or many processes. Since Chef role determines the recipes which are run on a node, a default attribute can be added to define the services JMXTrans is dependent on. The following is an example</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;
</span><span class='line'>&ldquo;default_attributes&rdquo; : {
</span><span class='line'>   &ldquo;jmxtrans&rdquo;:{
</span><span class='line'>      &ldquo;servers&rdquo;:[
</span><span class='line'>                  {
</span><span class='line'>                    &ldquo;type&rdquo;: &ldquo;datanode&rdquo;,
</span><span class='line'>                    &ldquo;service&rdquo;: &ldquo;hadoop-hdfs-datanode&rdquo;,
</span><span class='line'>                    &ldquo;service_cmd&rdquo;: &ldquo;org.apache.hadoop.hdfs.server.datanode.DataNode&rdquo;
</span><span class='line'>                  },
</span><span class='line'>                  {
</span><span class='line'>                    &ldquo;type&rdquo;: &ldquo;hbase_rs&rdquo;,
</span><span class='line'>                    &ldquo;service&rdquo;: &ldquo;hbase-regionserver&rdquo;,
</span><span class='line'>                    &ldquo;service_cmd&rdquo;: “org.apache.hadoop.hbase.regionserver.HRegionServer"
</span><span class='line'>                  }
</span><span class='line'>                ]
</span><span class='line'>              } &hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>Here the <code>service</code> key defines the name of the service on which JMXTrans is dependent on. The <code>service_cmd</code> key stores a string which can uniquely identify the running process of the service. The <code>type</code> key is not relevant for this discussion. These attributes will change for each role based on which service is installed as part of the role.</p>

<p>Since JMXTRans need to be installed, configured and started on all the nodes to collect statistics from various services a recipe need to be created for the same. But the recipe can now take into account the new node attribute to build the JMXTrans restart logic. The following is a sample code snippet which shows how the logic can be built</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;
</span><span class='line'>jmx_services = Array.new&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>node[&lsquo;jmxtrans&rsquo;][&lsquo;servers&rsquo;].each do |server|
</span><span class='line'>  jmx_services.push(server[&lsquo;service&rsquo;])
</span><span class='line'>  jmx_srvc_cmds[server[&lsquo;service&rsquo;]] = server[&lsquo;service_cmd&rsquo;]
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>service &ldquo;restart jmxtrans on dependent service&rdquo; do
</span><span class='line'>  service_name &ldquo;jmxtrans&rdquo;
</span><span class='line'>  supports :restart => true, :status => true, :reload => true
</span><span class='line'>  action   :restart
</span><span class='line'>  #
</span><span class='line'>  # Create subcribes entries for each of the services on which JMXTrans is dependent on
</span><span class='line'>  #
</span><span class='line'>  jmx_services.each do |jmx_dep_service|
</span><span class='line'>    subscribes :restart, &ldquo;service[#{jmx_dep_service}]&rdquo;, :delayed
</span><span class='line'>  end
</span><span class='line'>end
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>With the <code>subscribes</code> clause added to the <code>service</code> resource for every service JMXTrans is monitoring on the node, restarts of any of these services during <code>chef-client</code> run will make sure that JMXTrans service is restarted.</p>

<p>But what will happen if any of the dependent service is restarted externally for e.g. manually or upstart bounces a service. Then Chef will not restart JMXTrans during <code>chef-client</code> run since all the services are running. This will result in services restarted manually not being monitored by JMXTrans. The following is an updated code snippet which will handle this scenario. The complete recipe is available <a href="https://github.com/bloomberg/chef-bach/blob/master/cookbooks/bcpc_jmxtrans/recipes/default.rb">here</a>.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;
</span><span class='line'>jmx_services = Array.new
</span><span class='line'>jmx_srvc_cmds = Hash.new
</span><span class='line'>node[&lsquo;jmxtrans&rsquo;][&lsquo;servers&rsquo;].each do |server|
</span><span class='line'>  jmx_services.push(server[&lsquo;service&rsquo;])
</span><span class='line'>  jmx_srvc_cmds[server[&lsquo;service&rsquo;]] = server[&lsquo;service_cmd&rsquo;]
</span><span class='line'>end&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>service &ldquo;restart jmxtrans on dependent service&rdquo; do
</span><span class='line'>  service_name &ldquo;jmxtrans&rdquo;
</span><span class='line'>  supports :restart => true, :status => true, :reload => true
</span><span class='line'>  action   :restart
</span><span class='line'>  jmx_services.each do |jmx_dep_service|
</span><span class='line'>    subscribes :restart, &ldquo;service[#{jmx_dep_service}]&rdquo;, :delayed
</span><span class='line'>  end
</span><span class='line'>  #
</span><span class='line'>  # To determine any of the service JMXTrans depends on is started after JMXTrans service
</span><span class='line'>  #
</span><span class='line'>  only_if {process_require_restart?(&ldquo;jmxtrans&rdquo;,&ldquo;jmxtrans-all.jar&rdquo;, jmx_srvc_cmds)}
</span><span class='line'>end
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>As you may have noticed there is a <code>only_if</code> condition calls a library function which takes in a hash of all the services and the string which identifies the service processes as the third paramter. The first two paramters passed are the JMXTrans service name and a string which can uniquely identify a running JMXTrans process.</p>

<p>The following is the code snippet of the library function and the complete code can be found <a href="https://github.com/bloomberg/chef-bach/blob/master/cookbooks/bcpc_jmxtrans/libraries/utils.rb">here</a>.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def process_require_restart?(process_name, process_cmd, dep_cmds)
</span><span class='line'>  tgt_proces_pid = &lt;code>pgrep -f #{process_cmd}&lt;/code>
</span><span class='line'>  &hellip;
</span><span class='line'>  #
</span><span class='line'>  # Find the start time of the JMXTrans process
</span><span class='line'>  #
</span><span class='line'>  tgt_proces_stime = &lt;code>ps --no-header -o start_time #{tgt_process_pid}&lt;/code>
</span><span class='line'>  &hellip;
</span><span class='line'>  ret = false
</span><span class='line'>  restarted_processes = Array.new
</span><span class='line'>  #
</span><span class='line'>  # Loop through the processess of all the dependent services
</span><span class='line'>  #
</span><span class='line'>  dep_cmds.each do |dep_process, dep_cmd|
</span><span class='line'>    dep_pids = &lt;code>pgrep -f #{dep_cmd}&lt;/code>
</span><span class='line'>    if dep_pids != &ldquo;&rdquo;
</span><span class='line'>      dep_pids_arr = dep_pids.split(&ldquo;\n&rdquo;)
</span><span class='line'>      dep_pids_arr.each do |dep_pid|
</span><span class='line'>        #
</span><span class='line'>        # Find the start time of a dependent process
</span><span class='line'>        #
</span><span class='line'>        dep_process_stime = &lt;code>ps --no-header -o start_time #{dep_pid}&lt;/code>
</span><span class='line'>        #
</span><span class='line'>        # If the dependent process start time is greater than JMXTrans start time
</span><span class='line'>        # set the return value to true
</span><span class='line'>        #
</span><span class='line'>        if DateTime.parse(tgt_proces_stime) &lt; DateTime.parse(dep_process_stime)
</span><span class='line'>          restarted_processes.push(dep_process)
</span><span class='line'>          ret = true
</span><span class='line'>        end
</span><span class='line'>  &hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>The logic behind the library function is to compare the start time of the JMXTrans process against the start time of processes of all the services it is dependent on. If any of the dependent processes start time is later than the start time of JMXTrans process then the JMXTrans service will get restarted.</p>

<p>It would be good to have a Chef primitive that can accomplish what the library function does so that similar situations can use it. Hope this provides a solution option to restart a service dependent on multiple services during a <code>chef-client</code> run.</p>

<p>More notes on this category can be found <a href="http://blog.asquareb.com/blog/categories/chef/">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamically Requesting a Common Service in a Chef Managed Environment]]></title>
    <link href="http://asquareb.github.io/blog/2015/02/21/dynamically-requesting-a-common-service-in-a-chef-managed-environment/"/>
    <updated>2015-02-21T22:39:48-04:00</updated>
    <id>http://asquareb.github.io/blog/2015/02/21/dynamically-requesting-a-common-service-in-a-chef-managed-environment</id>
    <content type="html"><![CDATA[<p>In a cluster environment there can be a common service running on all the nodes in the cluster which may be requested by an application using the cluster. For e.g. in a distributed computing environment logs can be created on each node in the cluster and a common service on each cluster node can be a service which regularly copies log entries into a common location. Copying of logs can be a requirement for some of the applications/services running on the cluster nodes so that users can go to one location to view the log data from all the nodes instead of looking at each node. This can also help with managing the security of the cluster by providing access to this common location instead of providing access to all the nodes in the cluster.</p>

<!-- more -->


<p>But copying of the logs may not be a requirement for some other service or application and the requirement may change in the future. It is better to build a solution so that the changes in the requirements to copy logs can be accommodated dynamically.</p>

<p>To explain the pattern on how we can accomplish the requirement, we will assume <code>Apache Flume</code> as the component which will be installed on all the nodes in the cluster and will be used to copy the log file entries to a common location in HDFS. The following is one solution to satisfy the requirement.</p>

<p>Create a new cookbook or reuse an existing cookbook which will be used on all the nodes in the cluster. Create a node attribute which will store a hash of hashes. For e.g.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>default[&lsquo;bcpc&rsquo;][&lsquo;hadoop&rsquo;][&lsquo;copylog&rsquo;] = {}</span></code></pre></td></tr></table></div></figure></p>

<p>The following is the datastructure which will be used to populate the hash values to be stored in the attributes</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  &lsquo;app_id&rsquo; =>  { &lsquo;logfile&rsquo; => &ldquo;/path/file_name_of_log_file&rdquo;,
</span><span class='line'>                 &lsquo;docopy&rsquo; => true (or false)
</span><span class='line'>                },&hellip;
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>where the <code>app_id</code> is an unique id of an application which requests the service to copy its logs, <code>logfile</code> is the path of the logfile and <code>docopy</code> is a flag to enable and disable the request to copy the log files based on change in need. If an application requests more than one logfile to be copied the <code>appli_id</code> need to be made unique with in the application by adding additonal details like log name or a sequence number.</p>

<p>When an application need to make a request to copy its log file, in the application&rsquo;s recipe, request can be added to the node attribute. For e.g. if logs from the nodes running <code>hbase-region-server</code> need to copy its logs to the common location, code similar to the following can be included in the recipe installing and starting the <code>hbase-region-server</code> service.</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>node.default[&lsquo;bcpc&rsquo;][&lsquo;hadoop&rsquo;][&lsquo;copylog&rsquo;][&lsquo;hbase_regionserver_log&rsquo;] = {
</span><span class='line'>    &lsquo;logfile&rsquo; => &ldquo;/var/log/hbase/hbase-regionserver-#{node.hostname}.log&rdquo;,
</span><span class='line'>    &lsquo;docopy&rsquo; => true
</span><span class='line'>}&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>node.default[&lsquo;bcpc&rsquo;][&lsquo;hadoop&rsquo;][&lsquo;copylog&rsquo;][&lsquo;hbase_regionserver_out&rsquo;] = {
</span><span class='line'>    &lsquo;logfile&rsquo; => &ldquo;/var/log/hbase/hbase-regionserver-#{node.hostname}.out&rdquo;,
</span><span class='line'>    &lsquo;docopy&rsquo; => true
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure></p>

<p>Note here how an unique identifier is used as the <code>app_id</code> for the two log files from <code>hbase_regionserver</code> to be copied to the common location in HDFS.</p>

<p>For someone not familiar with <code>Flume</code>, flume agents can be used to move data and they need a config file which defines things like the source, sink, the type of sink,the target location etc. Since <code>Flume</code> need to be installed in all nodes in the cluster to be a common service, a recipe need to be created to install the software. But when it comes to start <code>Flume agents</code>, the recipe need to loop through the node attribute to create required Flume configuration files for each logfile copy requests made by the applications running on the node.</p>

<p>For e.g if the node is running only <code>hbase_regionserver</code> there will be two copy requests in the attribute for which the recipe need to create Flume configuration files and start the corresponding <code>Flume agents</code>. If there are other applications/services running on the node for e.g. <code>HDFS Datanode</code> and if the recipes make copy requests then the number of flume configs and <code>flume agents</code> running on the node will be more. The following is the code snippet on how the <code>Flume</code> recipe can accomplish this</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&hellip;
</span><span class='line'>node[&lsquo;bcpc&rsquo;][&lsquo;hadoop&rsquo;][&lsquo;copylog&rsquo;].each do |id,f|
</span><span class='line'>   if f[&lsquo;docopy&rsquo;]
</span><span class='line'>     template &ldquo;/etc/flume/conf/flume-#{id}.conf&rdquo; do
</span><span class='line'>       source &ldquo;flume_flume-conf.erb”
</span><span class='line'>       action :create &hellip;
</span><span class='line'>       variables(:agent_name => &rdquo;#{id}&ldquo;,
</span><span class='line'>                 :log_location => &rdquo;#{f[&lsquo;logfile&rsquo;]}&ldquo; )
</span><span class='line'>       notifies :restart,"service[flume-agent-multi-#{id}]&rdquo;,:delayed
</span><span class='line'>     end
</span><span class='line'>     service &ldquo;flume-agent-multi-#{id}&rdquo; do
</span><span class='line'>       supports :status => true, :restart => true, :reload => false
</span><span class='line'>       service_name &ldquo;flume-agent-multi&rdquo;
</span><span class='line'>       action :start
</span><span class='line'>       start_command &ldquo;service flume-agent-multi start #{id}&rdquo;
</span><span class='line'>       restart_command &ldquo;service flume-agent-multi restart #{id}&rdquo;
</span><span class='line'>       status_command &ldquo;service flume-agent-multi status #{id}&rdquo;
</span><span class='line'>     end
</span><span class='line'>&hellip;</span></code></pre></td></tr></table></div></figure></p>

<p>A complete <code>Flume</code> recipe which includes this feature is available <a href="https://github.com/bloomberg/chef-bach/blob/master/cookbooks/bcpc-hadoop/recipes/copylog.rb">here</a>.</p>

<p>By default the init.d script for Flume starts one <code>Flume agent</code>. But BIGTOP jira <a href="https://issues.apache.org/jira/browse/BIGTOP-1581">BIGTOP-1581</a> provides an option to start/stop/restart flume agents by passing agent names as in the <code>service</code> resource in the previous code snippet. The name passed need to have a corresponding Flume config file under the configuration folder. Since <code>Flume</code> recipe need to know the copy request from all the applications running on the node, it should be the last recipe to be run on the node. This can be accomplished by creating a role to include the <code>Flume</code> recipe and add it to the end of chef-client runlist of all the nodes.</p>

<p>Hope this provides a solution option in a similar situation where applications can dynamically request for a common service in an environment. Also note that the data structure can be expanded so that applications can make richer requests for e.g. in this case request to change the location of the common location where logs are copied into etc.</p>

<p>More notes on this category can be found <a href="http://blog.asquareb.com/blog/categories/chef/">here</a>.</p>
]]></content>
  </entry>
  
</feed>
